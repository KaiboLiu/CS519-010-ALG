report.txt
Kaibo Liu 932-976-427


CS 519-005, Algorithms (MS/MEng-level), Winter 2018
HW1 - Python 3, qsort, BST, and qselect
Due electronically on flip on Sunday Jan 14, 11:59pm.


0. Q: What's the best-case, worst-case, and average-case time complexities of quicksort.
   Briefly explain each case.

   A: For quicksort, the time complexities for each casee are:
      best-case: O(nlogn). 
         In the most balanced case, we can divide the list into two nearly equal pieces after each partition . So we can make only logn nested recursions before we reach a list of size 1. This means that the depth of the recursion tree is logn, and it's almost an balanced tree. Each level of calls needs only O(n) time to generate sublists. The result is that the algorithm uses only O(nlogn) time. 
      worst-case: O(n^2). 
         In common, the most unbalanced partition occurs when the pivot divides the list into two sublists of sizes 1 and n − 1. This may occur if the pivot repeatedly happensto be the smallest or largest element in the list, or when the list is all equal. If the pivot is fixed, then the worst-case is in a sorted, reversely sorted, or an all-equal list. Then each recursive call processes a list of size one less than the previous list. Finally, we can make n − 1 nested calls before we reach a list of size 1. This means that the call tree is a linear chain of n − 1 nested calls. The ith call does O(n − i) work to do the partition, and sum (1..n)=O(n^2), so in that case Quicksort takes O(n²) time.
      average-case: O(nlogn).
         A comparison sort cannot use less than log(n!) comparisons on average to sort n items. That is appoximately equal to n(log n − log e). Quicksort is not much worse than an ideal comparison sort. On average, quicksort has O(n^2) time complexity.

   
1. [WILL BE GRADED] 
   Quickselect with Randomized Pivot (CLRS Ch. 9.2).
   Filename: qselect.py
   Submitted.


2. Buggy Qsort Revisited

   In the slides we showed a buggy version of qsort which is weird in an interesting way:
   it actually returns a binary search tree for the given array, rooted at the pivot:

   >>> from qsort import *
   >>> tree = sort([4,2,6,3,5,7,1,9])
   >>> tree
   [[[[], 1, []], 2, [[], 3, []]], 4, [[[], 5, []], 6, [[], 7, [[], 9, []]]]]

   which encodes a binary search tree:

                      4
                    /   \
                  2       6
                 / \     / \
                1   3   5   7
                             \
                              9
   
   Now on top of that piece of code, add three functions: 
   * sorted(t): returns the sorted order (infix traversal)
   * search(t, x): returns whether x is in t
   * insert(t, x): inserts x into t (in-place) if it is missing, otherwise does nothing.

   >>> sorted(tree)
   [1, 2, 3, 4, 5, 6, 7, 9]
   >>> search(tree, 6)
   True
   >>> search(tree, 6.5)
   False
   >>> insert(tree, 6.5)
   >>> tree
   [[[[], 1, []], 2, [[], 3, []]], 4, [[[], 5, []], 6, [[[], 6.5, []], 7, [[], 9, []]]]]
   >>> insert(tree, 3)
   >>> tree
   [[[[], 1, []], 2, [[], 3, []]], 4, [[[], 5, []], 6, [[[], 6.5, []], 7, [[], 9, []]]]]

   Hint: both search and insert should depend on a helper function _search(tree, x) which 
   returns the subtree (a list) rooted at x when x is found, or the [] where x should 
   be inserted.

   e.g., 
   >>> tree = sort([4,2,6,3,5,7,1,9])        # starting from the initial tree
   >>> _search(tree, 3)
   [[], 3, []]
   >>> _search(tree, 0)
   []
   >>> _search(tree, 6.5)
   []
   >>> _search(tree, 0) is _search(tree, 6.5)
   False
   >>> _search(tree, 0) == _search(tree, 6.5)
   True
   
   Note the last two []'s are different nodes (with different memory addresses): 
   the first one is the left child of 1, while the second one is the left child of 7
   (so that insert is very easy).
   
   Filename: qsort.py
   
   Q: What are the time complexities for the operations implemented?

Debriefing (required!): --------------------------

1. Approximately how many hours did you spend on this assignment?
   A: 2 hours.
2. Would you rate it as easy, moderate, or difficult?
   A: I would rate it as easy.
3. Did you work on it mostly alone, or mostly with other people?
   A: Completely alone.
4. How deeply do you feel you understand the material it covers (0%–100%)? 
   A: I think I understand all what Professor Huang expects.
5. Any other comments?
   A: It's interesting to dig into the nature of BST. 

This section is intended to help us calibrate the homework assignments. 
Your answers to this section will *not* affect your grade; however, skipping it
will certainly do.
